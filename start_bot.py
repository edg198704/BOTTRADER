import asyncio
import signal
import os
from typing import Dict, Any

from config_loader import load_config
from bot_core.logger import setup_logging, get_logger
from bot_core.config import BotConfig, AIEnsembleStrategyParams
from bot_core.exchange_api import ExchangeAPI, MockExchangeAPI, CCXTExchangeAPI
from bot_core.position_manager import PositionManager
from bot_core.risk_manager import RiskManager
from bot_core.strategy import TradingStrategy
from bot_core import strategy as strategy_module
from bot_core.bot import TradingBot
from bot_core.telegram_bot import TelegramBot
from bot_core.monitoring import HealthChecker, InfluxDBMetrics, AlertSystem
from bot_core.data_handler import DataHandler
from bot_core.order_sizer import OrderSizer
from bot_core.position_monitor import PositionMonitor
from bot_core.order_lifecycle_manager import OrderLifecycleManager
from bot_core.trade_executor import TradeExecutor
from bot_core.utils import generate_indicator_rename_map

# Shared state for communication between components (e.g., Telegram and Bot)
shared_bot_state: Dict[str, Any] = {}

def validate_config(config: BotConfig):
    """
    Performs critical validation checks on the configuration to prevent runtime errors.
    """
    logger = get_logger(__name__)
    logger.info("Performing configuration validation...")

    # --- Validate AI Strategy Feature Columns ---
    if isinstance(config.strategy.params, AIEnsembleStrategyParams):
        logger.info("Validating AIEnsembleStrategy feature columns...")
        
        base_columns = {'open', 'high', 'low', 'close', 'volume'}
        
        try:
            rename_map = generate_indicator_rename_map(config.strategy.indicators)
            generated_columns = set(rename_map.values())
        except ValueError as e:
            # If map generation fails (e.g., missing alias for SMA), it's a critical config error.
            logger.critical(f"Configuration error in indicators: {e}")
            raise e

        available_columns = base_columns.union(generated_columns)
        required_columns = set(config.strategy.params.feature_columns)
        missing_columns = required_columns - available_columns
        
        if missing_columns:
            error_msg = (
                f"Configuration error: The AI strategy requires feature columns that are not "
                f"generated by the configured indicators. Missing columns: {list(missing_columns)}"
            )
            logger.critical(error_msg, required=list(required_columns), available=list(available_columns))
            raise ValueError(error_msg)
        
        logger.info("AI feature columns are valid and can be generated by DataHandler.")

    logger.info("Configuration validation passed.")

async def main():
    config = load_config('config_enterprise.yaml')
    setup_logging(config.logging.level, config.logging.file_path, config.logging.use_json)
    logger = get_logger(__name__)

    try:
        validate_config(config)
    except ValueError as e:
        logger.critical("Configuration is invalid. Bot cannot start.", error=str(e))
        return

    # --- Shared State & Dependency Injection ---
    latest_prices: Dict[str, float] = {}
    alert_system = AlertSystem()

    exchange_api = get_exchange_api(config)
    position_manager = PositionManager(
        config.database, 
        config.initial_capital,
        alert_system=alert_system
    )
    risk_manager = RiskManager(
        config.risk_management,
        alert_system=alert_system
    )
    strategy = get_strategy(config)
    order_sizer = OrderSizer()
    health_checker = HealthChecker()
    metrics_writer = InfluxDBMetrics(url=os.getenv('INFLUXDB_URL'), token=os.getenv('INFLUXDB_TOKEN'), org=os.getenv('INFLUXDB_ORG'), bucket=os.getenv('INFLUXDB_BUCKET'))

    data_handler = DataHandler(
        exchange_api=exchange_api,
        config=config,
        shared_latest_prices=latest_prices
    )

    position_monitor = PositionMonitor(
        config=config,
        position_manager=position_manager,
        shared_latest_prices=latest_prices
    )

    order_lifecycle_manager = OrderLifecycleManager(
        exchange_api=exchange_api,
        exec_config=config.execution,
        shared_latest_prices=latest_prices
    )

    # The TradeExecutor encapsulates all execution logic
    trade_executor = TradeExecutor(
        config=config,
        exchange_api=exchange_api,
        position_manager=position_manager,
        risk_manager=risk_manager,
        order_sizer=order_sizer,
        order_lifecycle_manager=order_lifecycle_manager,
        alert_system=alert_system,
        shared_latest_prices=latest_prices,
        market_details={} # This will be populated by the bot after loading
    )

    bot = TradingBot(
        config=config,
        exchange_api=exchange_api,
        data_handler=data_handler,
        strategy=strategy,
        position_manager=position_manager,
        risk_manager=risk_manager,
        health_checker=health_checker,
        position_monitor=position_monitor,
        trade_executor=trade_executor,
        alert_system=alert_system,
        shared_latest_prices=latest_prices,
        metrics_writer=metrics_writer,
        shared_bot_state=shared_bot_state
    )

    # Set the callback after bot is created to avoid circular dependency on init
    position_monitor.set_close_position_callback(bot._close_position)

    # --- Setup shared state and graceful shutdown ---
    shared_bot_state['stop_bot_callback'] = bot.stop
    loop = asyncio.get_running_loop()
    for sig in (signal.SIGINT, signal.SIGTERM):
        loop.add_signal_handler(sig, lambda: asyncio.create_task(bot.stop()))

    # --- Initialize and run components ---
    await position_manager.initialize() # Load historical PnL before starting
    await data_handler.initialize_data() # Load historical data before starting
    telegram_bot = TelegramBot(config.telegram, shared_bot_state)
    
    # Register Telegram as an alert handler if it's configured
    if telegram_bot.application:
        alert_system.register_handler(telegram_bot.create_alert_handler())
        logger.info("Telegram alert handler registered.")

    try:
        bot_task = asyncio.create_task(bot.run())
        telegram_task = asyncio.create_task(telegram_bot.run())
        await asyncio.gather(bot_task, telegram_task)
    except asyncio.CancelledError:
        logger.info("Main task cancelled.")
    finally:
        logger.info("Shutting down all components.")
        await telegram_bot.stop()
        # The bot.stop() is already called by the signal handler

def get_exchange_api(config: BotConfig) -> ExchangeAPI:
    if config.exchange.name == "MockExchange":
        return MockExchangeAPI()
    return CCXTExchangeAPI(config.exchange)

def get_strategy(config: BotConfig) -> TradingStrategy:
    """Dynamically loads and instantiates a strategy class by name."""
    logger = get_logger(__name__)
    # The strategy name is now inside the validated params object
    strategy_name = config.strategy.params.name
    strategy_params = config.strategy.params

    try:
        strategy_class = getattr(strategy_module, strategy_name)
        if not issubclass(strategy_class, TradingStrategy):
            raise TypeError(f"Strategy '{strategy_name}' is not a valid subclass of TradingStrategy.")
        
        logger.info(f"Loading strategy: {strategy_name}")
        # Pass the specific, validated params object to the constructor
        return strategy_class(strategy_params)
    except AttributeError:
        logger.critical(f"Strategy class '{strategy_name}' not found in bot_core/strategy.py.")
        raise ValueError(f"Unknown strategy: {strategy_name}")
    except TypeError as e:
        logger.critical(f"Strategy class '{strategy_name}' is not a valid strategy.", error=str(e))
        raise

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        print("\nBot shutdown requested. Exiting.")
